<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java-day15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/09/Java-day15/" class="article-date">
  <time class="dt-published" datetime="2021-02-09T09:07:02.000Z" itemprop="datePublished">2021-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/09/Java-day15/">Java day15</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><ul>
<li><p>环境变量</p>
<ul>
<li><p>path 让DOS系统可以找到java javac Javadoc jdk &gt;&gt;&gt; bin </p>
</li>
<li><p>JAVA_HOME </p>
<ul>
<li>简化path的配置 </li>
<li>Tomcat所依赖的环境变量</li>
</ul>
</li>
<li><p>classpath 然java指令的目录下去找字节码文件</p>
</li>
</ul>
</li>
<li><p>JavaAPI 帮助文档</p>
</li>
<li><p>java注释 单行// 多行/ * * /  文档 / * *  * /</p>
</li>
<li><p>java源代码 .java &gt;&gt;编译&gt;&gt; java字节码.class </p>
</li>
<li><p>java字节码.class &gt;&gt;反编译&gt;&gt; java源代码 .java</p>
</li>
<li><p>标识符 java中用于区分数据的名称</p>
<ul>
<li><p>类名 (文件名)</p>
</li>
<li><p>包名</p>
</li>
<li><p>方法名</p>
</li>
<li><p>变量名</p>
</li>
<li><p>可以使用 字母 数字 _</p>
</li>
<li><p>不可以 数字不能为开头 不能有空格</p>
<ul>
<li>字母开头 数字放后面 能不用符号不用符号 不得不用符号时候 只能$_</li>
</ul>
</li>
<li><p>类名首字母大写 其他首字母小写</p>
</li>
</ul>
</li>
<li><p>字符集</p>
</li>
<li><p>ASCII</p>
</li>
<li><p>ISO-8859-1</p>
</li>
<li><p>BIG5</p>
</li>
<li><p>GBK</p>
</li>
<li><p>unicode &gt;&gt;&gt; uft-8/utf-16/utf-32</p>
</li>
<li><p>变量</p>
<ul>
<li>声明</li>
<li>数据类型 变量名:</li>
<li>变量的赋值 =赋值符号 将右边的值或者是式子的运算结果赋值给左边的变量</li>
<li>变量名 = 值;</li>
<li>数据类型 变量名 = 值;</li>
<li>数据类型 变量名1 = 值1，变量名2 = 值2;</li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li>不可修改的变量 final修饰的变量</li>
</ul>
</li>
<li><p>全局变量 局部变量</p>
</li>
<li><p>声明在大括号里的变量，一般作用在该括号中</p>
</li>
<li><p>进制的转换 &gt;&gt;&gt; 了解一下二进制 </p>
</li>
<li><p>数据类型</p>
</li>
<li><p>java中数据类型一共分两类</p>
<ul>
<li><p>基本数据类型 8个</p>
<ul>
<li>四个整数类型 byte 1 -126 128 short 2 int 4 long 8 </li>
<li>两个浮点数型</li>
<li>一个字符型</li>
<li>一个布尔类型</li>
</ul>
</li>
<li><p>引用数据类型 类 抽象类 接口 枚举 …</p>
</li>
</ul>
</li>
</ul>
<h1 id="idea的使用细节"><a href="#idea的使用细节" class="headerlink" title="idea的使用细节"></a>idea的使用细节</h1><h2 id="idea创建项目"><a href="#idea创建项目" class="headerlink" title="idea创建项目"></a>idea创建项目</h2><ul>
<li><p>选择创建新项目 create new project</p>
<ul>
<li>Java 在JAVASE阶段 我们选择创建的项目类型</li>
<li>JAVA Enterprise 在JavaEE阶段 我们选择创建的项目类型</li>
</ul>
</li>
<li><p>选择jdk版本 选择1.8版本 一直指向jdk1.8.0.281文件夹 不用指向里面的目录</p>
</li>
<li><p>create project from template &gt;&gt;&gt; 是否使用模板创建项目 &gt;&gt;&gt; 不选</p>
</li>
<li><p>给项目命名并项目目录选择</p>
<ul>
<li>默认将项目存在C盘，最好自己选择</li>
<li>项目名可以数字开头 日期 + 内容</li>
<li>路径要加上 \ 项目名 表示在当前目录下，再创建一个该项目名的目录</li>
<li>仔细检查 项目存储路径中 不允许出现连续的 \ </li>
</ul>
</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/tip1.png" class title="This is an example image"></div>

<ul>
<li>勾选 View &gt;&gt;&gt; Appearance &gt;&gt;&gt; Toolbar\Tool Window Bars\Status Bar\Nevigation Bar\Main Menu 此为调试中常用的工具</li>
<li>一个完整的普通java项目如下</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/tip2.png" class title="This is an example image"></div>

<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/2021-02-10_190044.png" class title="This is an example image"></div>

<p>file &gt;&gt;&gt; settings &gt;&gt;&gt; Editor &gt;&gt;&gt; File Types &gt;&gt;&gt; Ignored Files and Folders<br>添入 .idea 与 * .iml</p>
<h2 id="Idea创建包"><a href="#Idea创建包" class="headerlink" title="Idea创建包"></a>Idea创建包</h2><p><strong><em>认识几个目录</em></strong></p>
<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/2021-02-10_191604.png" class title="This is an example image"></div>

<p>包 &gt;&gt;&gt; 受保护的资源目录 其实就是文件夹 只不过该种文件夹放于src中，一般专用于放代码和配置文件<br>包 放代码 放在src里<br>包的命名 必须是小写字母开头</p>
<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/2021-02-10_192044.png" class title="This is an example image"></div>

<p><strong><em>包作用</em></strong></p>
<ul>
<li>可以帮助我们给项目划分模块 </li>
<li>可以对不同的代码文件分类存储 </li>
<li>可以解决同名源代码的冲突问题 不同的包下可以存放同名的java源代码文件</li>
</ul>
<h2 id="idea创建java文件"><a href="#idea创建java文件" class="headerlink" title="idea创建java文件"></a>idea创建java文件</h2><p>选中包 demo1 &gt;&gt;&gt; new &gt;&gt;&gt; java class</p>
<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/2021-02-10_192701.png" class title="This is an example image"></div>

<p>起个名字 java中的类名 (文件名) 首字母必须大写</p>
<h2 id="idea运行主方法"><a href="#idea运行主方法" class="headerlink" title="idea运行主方法"></a>idea运行主方法</h2><p>快捷主方法 psvm + 回车</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;标志当前代码所在的包</span><br><span class="line">&#x2F;&#x2F;之前不允许有任何代码 可以有空格和注释</span><br><span class="line">package demo1;</span><br><span class="line"></span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    &#x2F;&#x2F;psvm</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;sout</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动主方法 &gt;&gt;&gt; 主方法的括号中 右击 run Test1.main()</p>
<div style="width:70%;margin:auto"><img src="/2021/02/09/Java-day15/2021-02-10_193741.png" class title="This is an example image"></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/09/Java-day15/" data-id="ckkzd1svz000aw0wzh2zu7jxy" data-title="Java day15" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming-Language/" rel="tag">Programming Language</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-虚拟内存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2021-02-06T09:25:22.000Z" itemprop="datePublished">2021-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">虚拟内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h1><h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/all.png" class title="This is an example image"></div>

<h2 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h2><div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/trod.png" class title="This is an example image"></div>

<p><strong><em>一次性:</em></strong> 作业必须一次性全部装入内存后才能开始运行。这会造成两个问题;</p>
<ol>
<li>作业很大时，不能全部装入内存，导致大作业无法运行:</li>
<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li>
</ol>
<p><strong><em>驻留性:</em></strong> 一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p><strong><em>时间局部性</em></strong> :如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<br><strong><em>空间局部性</em></strong> :一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p>
<p>如何应用局部性原理?</p>
<ul>
<li><strong><em>高速缓冲技术</em></strong> 的思想:将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。</li>
<li>快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/compare.png" class title="This is an example image"></div>

<h2 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h2><ul>
<li>基于 <strong><em>局部性原理</em></strong> ，在程序装入时，可以将程序中 <strong><em>很快会用到的部分装入内存</em></strong> ， <strong><em>暂时用不到的部分留在外存</em></strong> ，就可以让程序开始执行。</li>
<li>在程序执行过程中，当所访问的 <strong><em>信息不在内存时</em></strong> ，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</li>
<li>若内存空间不够，由 <strong><em>操作系统负责将内存中暂时用不到的信息换出到外存</em></strong> 。</li>
<li>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是 <strong><em>虚拟内存</em></strong></li>
</ul>
<p>操作系统虚拟性的一个体现,实际的物理内存大小没有变,只是在逻辑上进行了扩充。<br><strong><em>易混知识点:</em></strong></p>
<ul>
<li>虚拟内存的 <strong><em>最大容量</em></strong> 是由计算机的地址结构（CPU寻址范围）确定的</li>
<li>虚拟内存的 <strong><em>实际容量</em></strong> = min{内存和外存容量之和，CPU寻址范围}</li>
</ul>
<p>如:某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB<br>则虚拟内存的 <strong><em>最大容量</em></strong> 为2<sup>32</sup>B = 4GB<br>虚拟内存的 <strong><em>实际容量</em></strong> = min {2<sup>32</sup>B,512MB+2GB}= 2GB+512MB</p>
<p>虚拟内存有一下三个主要特征:</p>
<ol>
<li>多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
<li>对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>
<li>虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
</ol>
<h2 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h2><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在 <strong><em>离散分配</em></strong> 的内存管理方式基础上。</p>
<p>主要区别:</p>
<ul>
<li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 &gt;&gt;&gt; 操作系统要提供请求调页(或请求调段）功能</li>
<li>若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存。 &gt;&gt;&gt; 操作系统要提供页面置换（或段置换）的功能</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/conclusion.png" class title="This is an example image"></div>

<h1 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h1><p>请求分页存储管理与基本分页存储管理的主要区别:<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>
<ul>
<li>操作系统要提供请求调页功能,将缺失页面从外存调入内存</li>
<li>操作系统要提供页面置换的功能,将暂时用不到的页面换出外存</li>
</ul>
<h2 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h2><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。<br>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面:有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/new.png" class title="This is an example image"></div>

<p>请求页表新增加了四个字段，状态位、访问字段、修改位、外存地址</p>
<h2 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h2><ul>
<li>假设此时要访问逻辑地址=(页号，页内偏移量〉= (0,1024)</li>
<li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</li>
<li>此时缺页的进程阻塞，放入阻塞队列， <strong><em>调页完成后再将其唤醒</em></strong> ，放回就绪队列。</li>
<li>如果内存中 <strong><em>有空闲块</em></strong> ，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</li>
<li>如果内存中 <strong><em>没有空闲块</em></strong> ，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</li>
</ul>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于 <strong><em>内中断</em></strong><br>一条指令在执行期间，可能产生多次缺页中断。(如: copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p>
<div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/shutdown1.png" class title="This is an example image"></div>

<ul>
<li>新增步骤1:请求调页（查到页表项时进行判断)</li>
<li>新增步骤2:页面置换（需要调入页面，但没有空闲内存块时进行)</li>
<li>新增步骤3:需要修改请求页表中新增的表项</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>在逻辑地址变化为物理地址过程中，先检查页号的合法性</li>
<li>如果页号没有越界，则查询页号此时在快表中，有没有页号对应的页表项</li>
<li>如果快表命中，即可得到最终的物理地址</li>
<li>如果快表没有命中，查询内存中的满表</li>
<li>在找到对应的页表项之后，需要检查该页面是否已经在内存当中</li>
<li>如果没有在内存当中，缺页中断机构，会产生一个缺页中断的信号</li>
<li>之后会由操作系统的缺页中断处理程序进行处理，包括调页、页面置换一系类事情</li>
<li>当页面调入之后，也需要修改页表项对应的一些数据</li>
</ol>
<p>ps:快表中有的页面一定是在内存中的。若某个页面被换出外存,则快表中的相应表项也要删除,否则可能访问错误的页面</p>
<p>补充细节:</p>
<ol>
<li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>
<li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li>
<li>需要用某种“页面置换算法”来决定一个换出页面(下节内容)</li>
<li>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大开销。</li>
<li>页面调入内存后,需要修改慢表，同时也需要将表项复制到快表中。</li>
</ol>
<p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是:<br>查快表(未命中) &gt;&gt;&gt; 查慢表(发现未调入内存) &gt;&gt;&gt; 调页(调入的页面对应的表项会直接加入快表) &gt;&gt;&gt; 查快表(命中) &gt;&gt;&gt; 访问目标内存单元</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/conclusion1.png" class title="This is an example image"></div>

<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>请求分页存储管理与基本分页存储管理的主要区别:<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>
<p>用页面置换算法决定应该换出哪个页面<br>页面的换入、换出需要磁盘I/O，会有较大的开销,因此好的页面置换算法应该追求更少的缺页率</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" data-id="ckkzd1sx5002ow0wzheik0lyb" data-title="虚拟内存" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/" rel="tag">system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-页表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/04/%E9%A1%B5%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2021-02-04T08:33:09.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/04/%E9%A1%B5%E8%A1%A8/">页表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h1><h2 id="单级页表存在的问题"><a href="#单级页表存在的问题" class="headerlink" title="单级页表存在的问题"></a>单级页表存在的问题</h2><ul>
<li>某计算机系统按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B。</li>
<li>4KB= 2<sup>12</sup>B，因此页内地址要用12位表示，剩余20位表示页号。</li>
<li>因此，该系统中用户进程最多有2<sup>20</sup>页。相应的，一个进程的页表中，最多会有2<sup>20</sup>= 1M = 1,048,576个页表项，所以一个页表最大需要2<sup>20</sup> * 4B= 2<sup>22</sup>B，共需要2<sup>22</sup>/2<sup>12</sup>= 2<sup>10</sup>个页框存储该页表。</li>
<li>根据页号查询页表的方法:K号页对应的页表项存放位置=页表始址 + K * 4要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</li>
<li>需要专门给进程分配2<sup>10</sup> = 1024个连续的页框来存放它的页表</li>
<li>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</li>
</ul>
<p>ps: 每一个内存块大小=页面大小 一个页表项对应一个块号 每个页表项的大小4B</p>
<h2 id="如何解决单级页表的问题"><a href="#如何解决单级页表的问题" class="headerlink" title="如何解决单级页表的问题"></a>如何解决单级页表的问题</h2><ul>
<li>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li>
<li>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</li>
</ul>
<p>思考:我们是如何解决进程在内存中必须连续存储的问题的?<br>将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置</p>
<p>同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页<br>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB,每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中)<br>另外，要为离散分配的页表再建立一张页表，称为 <strong><em>页目录表</em></strong> ，或称外层页表，或称顶层页表</p>
<h2 id="两级页表的原理、地址结构"><a href="#两级页表的原理、地址结构" class="headerlink" title="两级页表的原理、地址结构"></a>两级页表的原理、地址结构</h2><p>32位逻辑地址空间，页表项大小为4B，页面大小为4KB，则页内地址占12位</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/page.png" class title="This is an example image"></div>

<p>为了记录小页表在内存块中的块号以及顺序，为小页表在建立上一级页表 &gt;&gt;&gt; 顶级页表<br>记录了二级页表的页号、在内存存储的块号的关系</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/page2.png" class title="This is an example image"></div>

<p>结构改为:一级页号(0-1023) + 二级页号 + 页内偏移量</p>
<h2 id="如何实现地址变换"><a href="#如何实现地址变换" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h2><ol>
<li>按照地址结构将逻辑地址拆分成三部分</li>
<li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li>
<li>根据二级页号查表，找到最终想访问的内存块号</li>
<li>结合页内偏移量得到物理地址</li>
</ol>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/page3.png" class title="This is an example image"></div>

<h2 id="如何结局单级页表问题"><a href="#如何结局单级页表问题" class="headerlink" title="如何结局单级页表问题"></a>如何结局单级页表问题</h2><p>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p>
<ul>
<li>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。</li>
<li>若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存</li>
</ul>
<h2 id="需要注意的几个细节"><a href="#需要注意的几个细节" class="headerlink" title="需要注意的几个细节"></a>需要注意的几个细节</h2><p>1.若采用多级页表机制，则各级页表的大小不能超过一个页面<br>例:某系统按字节编址，采用 40 位逻辑地址，页面大小为4KB，页表项大小为4B，假设采用纯页式存储，则要采用（)级页表，页内偏移量为（）位?</p>
<ul>
<li>页面大小= 4KB = 2<sup>12</sup>B，按字节编址，因此页内偏移量为12位</li>
<li>页号 = 40 - 12 = 28位</li>
<li>页面大小 = 2<sup>12</sup>B，页表项大小= 4B，则每个页面可存放2<sup>12</sup>/4 = 2<sup>10</sup>个页表项</li>
</ul>
<p>因此各级页表最多包含2<suo>10</suo>个页表项，需要10位二进制位才能映射到2<sup>10</sup>个页表项，因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级<br>如果只分为两级页表，则一级页号占18位,也就是说页目录表中最多可能有2<sup>18</sup>个页表项,显然,一个页面是放不下这么多页表项的。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/page4.png" class title="This is an example image"></div>

<p>2.两级页表的 <strong><em>访存次数分析</em></strong> （假设没有快表机构)</p>
<ul>
<li>第一次访存:访问内存中的页目录表</li>
<li>第二次访存:访问内存中的二级页表</li>
<li>第三次访存:访问目标内存单元</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/conclusion1.png" class title="This is an example image"></div>

<p>要能根据逻辑地址位数、页面大小、页表项大小确定多级页表的逻辑地址结构</p>
<h1 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h1><p>与“分页”最大的区别就是 – 离散分配时所分配地址空间的基本单位不同</p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><ul>
<li>进程的地址空间:按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</li>
<li>内存分配规则:以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</li>
<li>由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD，[D]&lt;A&gt;;		&#x2F;&#x2F;将分段D中的A单元内的值读入寄存器1</span><br><span class="line">STORE,[X]&lt;B&gt;;		&#x2F;&#x2F;将寄存器1的内容存入X分段的B单元中</span><br></pre></td></tr></table></figure>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para.png" class title="This is an example image"></div>

<ul>
<li><p>分段系统的逻辑地址结构由段号(段名）和段内地址（段内偏移量〉所组成。</p>
</li>
<li><p>段号的位数决定了每个进程最多可以分几个段</p>
</li>
<li><p>段内地址位数决定了每个段的最大长度是多少</p>
</li>
<li><p>在上述例子中，若系统是按字节寻址的，则</p>
<ul>
<li>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup>= 64K个段</li>
<li>段内地址占16位，因此每个段的最大长度是2<sup>16</sup> = 64KB。</li>
</ul>
</li>
<li><p>写程序时使用的段名[D]、[凶]会被编译程序翻译成对应段号</p>
</li>
<li><p><A>单元、<B>单元会被编译程序翻译成段内地址</B></A></p>
</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para2.png" class title="This is an example image"></div>

<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>问题:程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</p>
<p>1B为1字节，对应8bit，即8位二进制 </p>
<ol>
<li>每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称<br>“基址”）和段的长度。</li>
<li>各个段表项的长度是相同的。例如:某系统按字节寻址，采用分段存储管理，逻辑地址结构为(段号16位,段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16 + 32 = 48位，即6B。由于段表项长度相同， <strong><em>因此段号可以是隐含的</em></strong> ，不占存储空间。若段表存放的起始地址为M，则k号段对应的段表项存放的地址为M + K * 6</li>
</ol>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para3.png" class title="This is an example image"></div>

<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><ul>
<li>LOAD 1,[D] <A>; //将分段D中A单元内的值读入寄存器1</A></li>
<li>经过编译程序编译后，形成等价的机器指令:</li>
<li>“取出段号为2，段内地址为1024的内存单元中的内容，放到寄存器1中”</li>
<li>CPU执行指令时需要将逻辑地址变换为物理地址</li>
<li>机器指令中的逻辑地址用二进制表示: <strong><em>0000000000000010</em></strong> 0000000100000000</li>
</ul>
<p>进程未上处理机之前，段表寄存器寄存在在PCB中</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para4.png" class title="This is an example image"></div>

<p>由于分段中，各个段落存储量不一样，所以还要检查段内地址是否超过段长，这一点与分页不同。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para5.png" class title="This is an example image"></div>

<p>逻辑分析:</p>
<ol>
<li>若 {2,1024} ，即段号S=2;段内地址W=1024</li>
<li>首先用S和M进行一次检查，显然此时段表长度为3(有三个段0、1、2)，小于段号S，则段号合法</li>
<li>用段号和段表始值查到对应的段表项，这样就找到了2号段对应的段表</li>
<li>对段内地址合法性进行检查，将段内地址W和段长C进行对比</li>
<li>发现2号段段长为6K，而段内地址为1<br>024，可见段内地址小于段长，不会产生越界中断</li>
<li>根据段表项得知，该段在内存中存放 <strong><em>起始地址</em></strong> 是40K</li>
<li>用40K加上段内地址W=1024，得到最终想要访问的内存单元，也就是A变量存放的位置，完成对地址的访问</li>
</ol>
<h2 id="分段、分页管理对比"><a href="#分段、分页管理对比" class="headerlink" title="分段、分页管理对比"></a>分段、分页管理对比</h2><ul>
<li><strong><em>页</em></strong> 是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li>
<li><strong><em>段</em></strong> 是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li>
<li><strong><em>页</em></strong> 的大小固定且由系统决定。 <strong><em>段</em></strong> 的长度却不固定，决定于用户编写的程序。</li>
<li><strong><em>分页</em></strong> 的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</li>
<li><strong><em>分段</em></strong> 的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
<li><strong><em>分段</em></strong> 比 <strong><em>分页</em></strong> 更容易实现信息的共享和保护。</li>
<li>不能被修改的代码称为 <strong><em>纯代码或可重入代码</em></strong> （不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的(比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一时)</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para6.png" class title="This is an example image"></div>

<p>对于分页，则不易实现共享与保护。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/para7.png" class title="This is an example image"></div>

<p><strong><em>访问一个逻辑地址:需要几次访存?</em></strong></p>
<ul>
<li>分页（单级页表)﹔第一次访存 &gt;&gt;&gt; 查内存中的页表，第二次访存 &gt;&gt;&gt; 访问目标内存单元。总共两次访存</li>
<li>分段:第一次访存 &gt;&gt;&gt; 查内存中的段表，第二次访存 &gt;&gt;&gt; 访</li>
</ul>
<p>与分页系统类似，分段系统中也可以引入 <strong><em>快表机构</em></strong> ，将近期访问过的段表项放到快表中，这样可以小一次访问，加快地址变换速度。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/conclusion2.png" class title="This is an example image"></div>

<h1 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h1><h2 id="分页、分段的优缺点分析"><a href="#分页、分段的优缺点分析" class="headerlink" title="分页、分段的优缺点分析"></a>分页、分段的优缺点分析</h2><div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/difference.png" class title="This is an example image"></div>

<p>分段管理中产生的外部碎片也可以用“紧凑”来解决,只是需要付出较大的时间代价</p>
<h2 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段 + 分页 = 段页式管理"></a>分段 + 分页 = 段页式管理</h2><ul>
<li>将进程按逻辑模块分段，再将各段分页（如每个页面4KB)</li>
<li>再将内存空间分为大小相同的内存块/页框/页帧/物理块</li>
<li>进程前将各页面分别装入各内存块中</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/pro.png" class title="This is an example image"></div>

<h2 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h2><ul>
<li>分段系统的逻辑地址结构由段号和段内地址（段内偏移量）组成。</li>
<li>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量〉组成。</li>
<li>将段号拆为页号+页内地址</li>
<li><strong><em>段号的位数</em></strong> 决定了每个进程最多可以分几个段</li>
<li><strong><em>页号位数</em></strong> 决定了每个段最大有多少页</li>
<li><strong><em>页内偏移量</em></strong> 决定了页面大小、内存块大小是多少</li>
</ul>
<p>在上述例子中，若系统是按字节寻址的，则<br>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup>=64K个段<br>页内偏移量占12位，因此每个页面\每个内存块大小为2<sup>12</sup> = 4096 = 4KB<br>“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。<br>因此 <strong><em>段页式管理的地址结构是二维的</em></strong> 。</p>
<h2 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h2><p>每个段对应一个段表项，每个段表项由段号、 <strong><em>页表长度、页表存放块号</em></strong> （页表起始地址）组成。每个 <strong><em>段表项长度相等,段号是隐含的</em></strong> 。<br>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/pro2.png" class title="This is an example image"></div>

<p>一个进程会对应一个段表，但是一个进程可能对应多个页表</p>
<h2 id="怎么实现段页式管理中的逻辑地址转换为物理地址过程"><a href="#怎么实现段页式管理中的逻辑地址转换为物理地址过程" class="headerlink" title="怎么实现段页式管理中的逻辑地址转换为物理地址过程"></a>怎么实现段页式管理中的逻辑地址转换为物理地址过程</h2><ol>
<li>系统中会有个 <strong><em>段表寄存器</em></strong> 这个硬件</li>
<li>进程上处理器之前，会从PCB中读出段表始址F、段表长度M，放到段表寄存器当中</li>
<li>在进行地址转换时，第一步需要根据逻辑地址得到段号、页号、页内偏移量</li>
<li>将段号和段表长度进行对比，检查段号是否越界，是否合法</li>
<li>如果越界，会抛出一个中断，会由中断处理程序进行处理；如果没有越界，则段号合法，程序可以继续执行</li>
<li>根据段号和段表始址，来计算出段号对应的段表项，在内存中的位置，这样就找到了想找的段表项</li>
<li>由于各个段的长度不一样，所以各个段把他们分页之后，可能分为数量不等的一些页面，比如说有的段长一些，就可以分为两个页面，有的段短一些，只需要一个页面。所以由于各个段分页之后，各个页面数量可能不同。因此需要对页号的合法性进行检查。</li>
<li>如果页号没有超出页表长度，可以继续执行</li>
<li>通过段表项，得知页表存放的位置，读出页表，可以根据页号找到想要找的页表项</li>
<li>找到页表项之后，就可以知道，这个页面在内存中存放的位置</li>
<li>可以根据页表项中对应的内存块号和页内偏移量，进行二进制的拼接，形成要访问的物理地址</li>
<li>最终根据物理地址，访问目标单元</li>
</ol>
<p>在段页式管理当中，进行地址转换的过程需要三次访存:</p>
<ol>
<li>访问段表</li>
<li>访问页表</li>
<li>访问最终的目标单元</li>
</ol>
<div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/pro3.png" class title="This is an example image"></div>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/04/%E9%A1%B5%E8%A1%A8/conclusion3.png" class title="This is an example image"></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/04/%E9%A1%B5%E8%A1%A8/" data-id="ckkzd1sx8002uw0wzfqclatyr" data-title="页表" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/" rel="tag">system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java-day14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/02/Java-day14/" class="article-date">
  <time class="dt-published" datetime="2021-02-02T09:22:34.000Z" itemprop="datePublished">2021-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/02/Java-day14/">Java day14</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="写一个Java程序"><a href="#写一个Java程序" class="headerlink" title="写一个Java程序"></a>写一个Java程序</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h2 id="JVM-JRE"><a href="#JVM-JRE" class="headerlink" title="JVM/JRE/"></a>JVM/JRE/</h2><p>JVM &gt;&gt;&gt; 虚拟机 翻译功能<br>JRE &gt;&gt;&gt; Java Runtime Environment 包含JVM、库函数、运行Java所必须的文件<br>JDK &gt;&gt;&gt; Development Kit 包含JRE，以及增加编译器和调试器等用于程序开发的文件</p>
<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><ul>
<li><p>编写源代码 </p>
<ul>
<li>创建一个文件</li>
<li>创建一个类</li>
<li>定义主方法</li>
<li>在主方法中添加功能代码</li>
</ul>
</li>
<li><p>编译源代码 &gt;&gt;&gt; 将源代码编译成中立的字节码</p>
</li>
<li><p>解释源代码 &gt;&gt;&gt; 让虚拟机向平台解释字节码</p>
</li>
</ul>
<p>1.创建一个文件 &gt;&gt;&gt; Java代码文件就是纯文本文件 文件名的扩展名叫.java<br>文件名首字母必须大写 不能以数字为开头 不能有空格和特殊符号<br>标准写法 大写字母 数字放后面</p>
<p>2.创建一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Text1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;public (公开的) class(类) + Text1(类名 &gt;&gt;&gt;必须是文件名同名，包括大小写)</span><br><span class="line">在大括号中写代码</span><br></pre></td></tr></table></figure>
<p>3.定义主方法<br>程序的起点 程序的开始 在一个类中 只能有一个主代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Text1&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在主方法中定义功能代码<br>功能 向DOS 控制台输出一段文字 “hello world”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Text1&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		System.out.println(&quot;hello world&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译、解释文件"><a href="#编译、解释文件" class="headerlink" title="编译、解释文件"></a>编译、解释文件</h2><ul>
<li><p>先配置环境变量</p>
<ol>
<li>先找jdk中bin目录 C:\Program Files\Java\jdk1.8.0_281\bin</li>
<li>找其中的java.exe 和 javac.exe 两个文件</li>
<li>配置环境变量就是告诉DOS窗口这两个文件在这里</li>
<li>复制上诉路径 主电脑 &gt;&gt;&gt; 属性 &gt;&gt;&gt; 高级系统设置 &gt;&gt;&gt; 高级 &gt;&gt;&gt; 环境变量 &gt;&gt;&gt; 系统变量 &gt;&gt;&gt; PATH</li>
<li>将上述路径加入即可</li>
</ol>
</li>
<li><p>生成字节码</p>
<ol>
<li>打开CMD</li>
<li>进入.java文件的目录</li>
<li>输入 javac Text1.java</li>
<li>发现该文件夹下出现 .class 文件则环境变量配置成功</li>
<li>此时已将java源代码转换为字节码</li>
</ol>
</li>
<li><p>用Java指令将字节码交给虚拟机，让虚拟机解释执行</p>
<ol>
<li>仍然在文件目录里</li>
<li>输入 java Text1 此处不写.class也是默认寻找.class文件</li>
<li>解释成功 出现 hello world</li>
</ol>
</li>
</ul>
<p>ps:第二天突然javac不能用，只能用java,但是重启电脑之后就好了，不明所以。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><ul>
<li><p>Java的核心机制</p>
<ol>
<li><p>垃圾回收机制</p>
</li>
<li><p>跨平台机制 互联网发展要求有一款语言跨平台性能优越 Java的核心优势</p>
<ul>
<li><p>Java核心技术 虚拟机</p>
</li>
<li><p>Java的跨平台原理</p>
<ol>
<li><p>Java源代码 &gt;&gt;&gt;&gt; 扩展名为.java的纯文本文件</p>
<ul>
<li>定义一个类</li>
<li>在类中定义主方法</li>
<li>在主方法中定义功能代码</li>
</ul>
</li>
<li><p>Java源代码 &gt;&gt; 编译.javac &gt;&gt; 中立的二进制的字节码 扩展名为.class的文件</p>
</li>
<li><p>调用虚拟机平台解释JAVA字节码 java指令</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>为了让DOS系统识别到javac和java指令 可以在指定的目录中找到这两个指令 在环境变量中添该路径</p>
</li>
<li><p>DOS</p>
<ul>
<li>DIR 查看当前目录下的子文件和子目录</li>
<li>cd 切换目录 cd.. cd / cd 目录名/目录名</li>
<li>cls 清空命令</li>
</ul>
</li>
<li><p>掌握的三个操作</p>
<ul>
<li>tab 自动补全目录名/文件名</li>
<li>上下键 翻阅历史记录</li>
<li>盘符: 切换磁盘</li>
</ul>
</li>
<li><p>了解其他操作</p>
<ul>
<li>rd 删除目录</li>
<li>md 创建目录</li>
<li>copy 复制文件</li>
<li>del 删除文件</li>
</ul>
</li>
</ul>
<h1 id="配置JAVA-HOME-必须掌握"><a href="#配置JAVA-HOME-必须掌握" class="headerlink" title="配置JAVA_HOME(必须掌握)"></a>配置JAVA_HOME(必须掌握)</h1><p>此电脑 &gt;&gt;&gt; 属性 &gt;&gt;&gt; 高级系统设置 &gt;&gt;&gt; 高级 &gt;&gt;&gt; 环境变量<br>为了降低Java环境发生变动时，对环境变量的修改量，添加JAVA_HOME</p>
<ol>
<li>新建系统变量 变量名JAVA_HOME 名字不允许丝毫改变</li>
<li>将几个路径的共同部分放入变量值</li>
<li>此时该变量与之前配的变量之间没有联系</li>
<li>将之前配的变量路径中，共同的部分换位 %JAVA_HOME% 代表了对其他变量的引用 必须加百分号</li>
<li>注意 JAVA_HOME 的路径末尾没有斜线 而对其引用之后要加斜线 (只能有一处有)</li>
</ol>
<p><strong><em>作用：</em></strong></p>
<ul>
<li>可以降低环境变量维护工作量</li>
<li>后续其他技术可以使用的必要条件<ul>
<li><p>Tomcat 的启动要依赖系统中的 JAVA_HOME </p>
<h1 id="配置-classpath"><a href="#配置-classpath" class="headerlink" title="配置 classpath"></a>配置 classpath</h1></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac f:&#x2F;program4it&#x2F;Java&#x2F;myJava&#x2F;Text1.java</span><br><span class="line">&#x2F;&#x2F;但是java不能这么用</span><br></pre></td></tr></table></figure>
<ul>
<li>java指令会把后面的全部文字当成类名，不会识别其中的盘符和各层级的目录</li>
<li>classpath作用就是告诉java指令到指定的目录中去寻找字节码文件</li>
</ul>
<p>系统变量中 添加 变量名classpath 变量值F:\program4it\Java\myJava<br>ps:注意配置完之后，全部确认退出，重新打开cmd命令窗口才生效<br>ps:此时java指令只在该文件夹下找.class文件，其他文件夹下皆不生效</p>
<p>因此将变量值改为 .;F:\program4it\Java\myJava &gt;&gt;&gt; 先在DOS目前指定的目录中寻找字节码 如果找不到 再到 F:\program4it\Java\myJava中寻找</p>
<p>ps:试一下就可以了，实际的意义不大</p>
<h1 id="JAVA的API帮助文档"><a href="#JAVA的API帮助文档" class="headerlink" title="JAVA的API帮助文档"></a>JAVA的API帮助文档</h1><ul>
<li>JDK API 帮助文档</li>
<li>SUN公司为JDK工具包提供的一整套文档资料</li>
<li>JAVA中的各种技术详细资料 1.6版的比较好</li>
</ul>
<h1 id="JAVA编程风格"><a href="#JAVA编程风格" class="headerlink" title="JAVA编程风格"></a>JAVA编程风格</h1><ul>
<li><p>注意缩进</p>
</li>
<li><p>成对编程</p>
</li>
<li><p>注意命名</p>
</li>
<li><p>区分大小写</p>
</li>
<li><p>驼峰式命名</p>
<ul>
<li>标识符命名时，当多个单词拼接时，每个单词的首字母大写，其他小写</li>
</ul>
</li>
<li><p>Java中注释方式</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单行注释 &#x2F;&#x2F;</span><br><span class="line">多行注释 &#x2F;* *&#x2F; 可以一次性注释多行</span><br><span class="line">文档注释 </span><br><span class="line">&#x2F;**</span><br><span class="line">一般注释方法和类</span><br><span class="line">*&#x2F;  可以将文档注释中的内容生成自己的API帮助文档</span><br></pre></td></tr></table></figure>
<p>ps:生成API方法 </p>
<ol>
<li>用notepad++ 将编码转换为“使用ANSI格式编码”</li>
<li>注意，先全选复制，删除原来代码，再将编码格式设置为”使用ANSI格式编码”,然后将源文件再粘贴出来</li>
<li>在cmd运行 Javadoc Test1.java 即可在当前文件夹下生成API文档</li>
</ol>
<h1 id="notepad-的使用"><a href="#notepad-的使用" class="headerlink" title="notepad++ 的使用"></a>notepad++ 的使用</h1><p>按住 Ctrl 上下拨动滑轮 调整大小<br>可以直接保存Java source file</p>
<ol>
<li><p>乱码问题 原因</p>
<ol>
<li><p>文件的写入和读取使用的字符集不一致</p>
<ul>
<li>文件字符集 和 DOS窗口所使用的默认字符集不一致</li>
<li>Notepad++创建文件时 一般默认保存时使用 utf-8 国际通用字符集</li>
<li>DOS 系统默认使用 本地系统字符集 ANSI –&gt; 中文系统GBK   </li>
<li>一般世界上所有字符集 对于英文字母的处理都是一样的</li>
</ul>
</li>
<li><p>使用了不支持中文的字符</p>
</li>
<li><p>设置 notepad++ 在新建文件时候的首选项</p>
</li>
<li><p>再次用 notepad++ 新建java，输出中文测试</p>
</li>
</ol>
</li>
</ol>
<div style="width:70%;margin:auto"><img src="/2021/02/02/Java-day14/pref.png" class title="This is an example image"></div>

<h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p>jd-gui.exe</p>
<ul>
<li>因为编译的时候不会对注释进行处理，所以反编译时不可能的得到注释</li>
</ul>
<h1 id="第二个-java小程序"><a href="#第二个-java小程序" class="headerlink" title="第二个 java小程序"></a>第二个 java小程序</h1><ul>
<li>演示一些常见的错误</li>
<li>输出一段文字<ul>
<li>可以在搜狗输入法勾选 中文时使用英文标点</li>
</ul>
</li>
</ul>
<h1 id="标识符，关键字，字符集"><a href="#标识符，关键字，字符集" class="headerlink" title="标识符，关键字，字符集"></a>标识符，关键字，字符集</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>Java中用于区分数据需要我们自己定义的名称</li>
<li>允许使用 字母 数字 _ $</li>
<li>不允许使用 数字不能开头 不可以是java的关键字</li>
<li>驼峰式命名 StudentAge</li>
<li>见名知意</li>
<li>常见表示符:包名 类名 方法名 变量名 参数名</li>
<li>除了类名首字母大写 其他标识符首字母都要小写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;标志在代码中的目录名 &gt;&gt;&gt; 包名</span><br><span class="line">&#x2F;&#x2F;受保护的资源文件夹</span><br><span class="line">&#x2F;&#x2F;区分多个不同目录下的同名文件</span><br><span class="line">package myJava;</span><br><span class="line">         &#x2F;&#x2F;类名</span><br><span class="line">public class Demo2&#123;</span><br><span class="line">                  &#x2F;&#x2F;方法名</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      &#x2F;&#x2F;变量名</span><br><span class="line">      int i &#x3D; 10;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line">                  &#x2F;&#x2F;方法名  a b 参数名</span><br><span class="line">   public static void add(int a,int b)&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在cmd中，上一级目录录下就可以执行 javac myJava/Demo2.java<br>此时需要加上包名</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul>
<li>关键字就是对java有特殊含义的词汇，比如: public,static,int,class等</li>
<li>java关键字是java语言保留供内部使用的，如class定义类，关键字也可以成为保留字</li>
</ul>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>编码是信息从一种形式转换成另一种形式的过程，也称为计算机编程语言</p>
<ul>
<li>ASCII &gt;&gt;&gt; 英文字符集 1个字节 &gt;&gt; 8bit &gt;&gt; 8位10 &gt;&gt; 256个</li>
<li>ISO-8859-1 &gt;&gt;&gt; 西欧字符集 1个字节</li>
<li>BIG5 &gt;&gt;&gt; 台湾的五大码，表示繁体汉字 2个字节 16位</li>
<li>GB2312 &gt;&gt;&gt; 大陆使用最早，最广的简体中文字符集 2个字节</li>
<li>GBK &gt;&gt;&gt; GB2312的扩展 可以表示繁体汉字 2个字节</li>
<li>GB18090 &gt;&gt;&gt; 最新GBK的扩展，可以表示汉字，维吾尔文、藏文等中华名族字符 2个字节</li>
<li>Unicode &gt;&gt;&gt; 国际通用字符集 2个字节 (JAVA中使用的字符集就是Unicode)</li>
</ul>
<p>ps:</p>
<ul>
<li>Unicode 是字符集，UTF-32/UTF-16/UTF-8 是三种字符编码方案</li>
<li>ANSI:获取你当前操作系统的编码格式 &gt;&gt;&gt; 一般我们用GBK</li>
<li>1位 1/0 &gt;&gt;&gt; bit 比特</li>
<li>1字节 8比特 &gt;&gt;&gt; byte 字节</li>
<li>千字节 1024byte 兆字节 1024kB</li>
<li>GB = 1024MB; TB = 1024GB; PB = 1024TB</li>
<li>字符 &gt;&gt;&gt; 代表一个文字 可以是一个字母 中文 空格 标点符号</li>
</ul>
<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><ul>
<li>变量 &gt;&gt;&gt; 可以变化的量</li>
<li>常量 &gt;&gt;&gt; 不会变量的量<ul>
<li>字面常量 &gt;&gt;&gt; 就是具体的值 5 -&gt; 6 变得是年龄而不是5变成6</li>
<li>符号常量 &gt;&gt;&gt; 类似于π</li>
</ul>
</li>
</ul>
<h2 id="变量的声明和使用"><a href="#变量的声明和使用" class="headerlink" title="变量的声明和使用"></a>变量的声明和使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test1&#123;</span><br><span class="line">   public static void main(String[] args)&#123;      </span><br><span class="line">      &#x2F;*变量的声明(我要创建一个变量) &gt;&gt;&gt; 数据类型 变量名; </span><br><span class="line">      java 强类型的编程语言 JAVA中的任何一个变量都必须明确指明其数据类型</span><br><span class="line">      int 整数</span><br><span class="line">      变量的声明 仅仅是一种声明 不会在内存上实际开辟内存存储数据</span><br><span class="line">      *&#x2F;</span><br><span class="line">      int i;   &#x2F;&#x2F;不会在字节码中有任何处理</span><br><span class="line">      &#x2F;*</span><br><span class="line">      给变量赋值 才会在内存中 开辟一个空间 这个空间存储一个值 10;</span><br><span class="line">      *&#x2F;</span><br><span class="line">      i &#x3D; 10;  &#x2F;&#x2F;才会在字节码中 正式声明一个变量</span><br><span class="line">      int t &#x3D; 10; &#x2F;&#x2F;声明变量同时赋值</span><br><span class="line">      System.out.println(i);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;可以一次性声明多个变量</span><br><span class="line">      int a&#x3D;1,b&#x3D;2,c&#x3D;3,d&#x3D;4;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      System.out.println(b);</span><br><span class="line">      System.out.println(c);</span><br><span class="line">      System.out.println(d);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;变量的值是可以反复修改的</span><br><span class="line">      int x &#x3D; 11;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">      &#x2F;&#x2F;变量只要声明一次类型即可 后面直接使用变量 不需要反复声明</span><br><span class="line">      x&#x3D;12;</span><br><span class="line">      System.out.println(x);</span><br><span class="line">   &#125;</span><br><span class="line">            </span><br><span class="line">   public static void add(int a,int b)&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h1><ul>
<li><p>局部变量</p>
<ul>
<li>方法内/代码块内/多条件分支或者循环内声明的变量，仅能够在当前方法内/代码块内/多条件分支或循环内</li>
</ul>
</li>
<li><p>成员变量(全局变量)</p>
<ul>
<li>声明在方法之外的变量 可以通过访问修饰符控制访问范围，但至少可以在当前内部可见</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test2&#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;成员变量 至少可以在当前类所有的方法中使用</span><br><span class="line">   static int z &#x3D; 20;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;      </span><br><span class="line">      &#x2F;&#x2F;局部变量 当前方法内 声明在方法中</span><br><span class="line">      int i &#x3D; 10;</span><br><span class="line">      System.out.println(i);</span><br><span class="line"></span><br><span class="line">      for(int x &#x3D; 1;x&lt;&#x3D;10;x++)&#123;</span><br><span class="line">         &#x2F;&#x2F;局部变量 声明在循环结构内部 仅仅在当前循环内部可以使用</span><br><span class="line">         int y &#x3D; 10;</span><br><span class="line">         System.out.println(y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(z);</span><br><span class="line">      a();</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   public static void a()&#123;</span><br><span class="line">      System.out.println(z);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>字面值常量 1 2 3 4</li>
<li>符号常量 圆周率</li>
<li>不可修改的变量 &gt;&gt;&gt; 常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test3&#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;      </span><br><span class="line">      &#x2F;&#x2F;final 修饰的变量叫做常量 只能赋值一次 不可以修改值</span><br><span class="line">      final int i &#x3D; 10;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">      i &#x3D; 11;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java中的数据类型"><a href="#java中的数据类型" class="headerlink" title="java中的数据类型"></a>java中的数据类型</h1><h2 id="进制及其转换"><a href="#进制及其转换" class="headerlink" title="进制及其转换"></a>进制及其转换</h2><p>十进制 逢十进一 &gt;&gt;&gt; 人类喜欢的进制<br>二进制 逢二进一 &gt;&gt;&gt; 计算机底层的进制 运算快 不容易出错 运算准确</p>
<p>转换:顺序分解 逆序取余</p>
<ul>
<li>十进制 D</li>
<li>二进制 B</li>
<li>八进制 Q</li>
<li>十六进制 H</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本数据类型 (primitive data type):最基础的数据类型 八种<ul>
<li>整数型 tyte short int long</li>
<li>浮点型 float double 小数</li>
<li>字符型 chair</li>
<li>布尔型 boolean  true false 做逻辑判断</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test4&#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;      </span><br><span class="line">      &#x2F;*</span><br><span class="line">      字节型整数 8比特 8位 1字节 存储一个整数 </span><br><span class="line">      00000000 -- 11111111 即256个整数 -128 --127</span><br><span class="line">      *&#x2F;</span><br><span class="line">      byte b &#x3D; -128;</span><br><span class="line">      &#x2F;*</span><br><span class="line">      短整型整数 16位 2字节 65536 -32768 -- 23767</span><br><span class="line">      *&#x2F;</span><br><span class="line">      short c &#x3D; 10;</span><br><span class="line">      &#x2F;*</span><br><span class="line">      整数型 32位 4字节 -21亿 -- 21亿 默认存储整数常量的类型</span><br><span class="line">      *&#x2F;</span><br><span class="line">      int i &#x3D; 10;</span><br><span class="line">      &#x2F;*</span><br><span class="line">      长整型整数 64位 8字节 后面接L</span><br><span class="line">      *&#x2F;</span><br><span class="line">      long l &#x3D; 11111111111L;</span><br><span class="line">      </span><br><span class="line">      System.out.println(b);</span><br><span class="line">      System.out.println(c);</span><br><span class="line">      System.out.println(i);</span><br><span class="line">      System.out.println(l);</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何写各种进制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test5&#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;      </span><br><span class="line">      &#x2F;&#x2F;十进制整数 如:99 -599 0</span><br><span class="line">      int a &#x3D; 55;</span><br><span class="line">      &#x2F;&#x2F;八进制整数 要求以0开头 如:015 &gt;&gt;&gt; 15</span><br><span class="line">      int b &#x3D; 015;</span><br><span class="line">      &#x2F;&#x2F;十六进制整数 要求以0x或0X开头 如:0x15 &gt;&gt;&gt; 21</span><br><span class="line">      int c &#x3D; 0x15;</span><br><span class="line">      &#x2F;&#x2F;二进制 要求以0b或0B开头 如:0b11</span><br><span class="line">      int d &#x3D; 0b11;</span><br><span class="line">      </span><br><span class="line">      System.out.println(a);</span><br><span class="line">      System.out.println(b);</span><br><span class="line">      System.out.println(c);</span><br><span class="line">      System.out.println(d);</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用数据类型 (reference data type):类 抽象类 接口 枚举 …</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/02/Java-day14/" data-id="ckkzd1svy0008w0wzdznae348" data-title="Java day14" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming-Language/" rel="tag">Programming Language</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-supervisor-mode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/01/supervisor-mode/" class="article-date">
  <time class="dt-published" datetime="2021-02-01T07:48:53.000Z" itemprop="datePublished">2021-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/01/supervisor-mode/">supervisor mode</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><p>ps: <strong><em>连续分配</em></strong> 指为用户进程分配的必须是一个连续的内存空间。</p>
<h2 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h2><ul>
<li>在单一连续分配方式中，内存被分为 <strong><em>系统区</em></strong> 和 <strong><em>用户区</em></strong> 。</li>
<li>系统区通常位于内存的低地址部分，用于存放操作系统相关数据:用户区用于存放用户进程相关数据。</li>
<li>内存中只能有 <strong><em>一道用户程序</em></strong> ，用户程序独占整个用户区空间。</li>
</ul>
<p><strong><em>优点</em></strong> :</p>
<ol>
<li>实现简单: <strong><em>无外部碎片</em></strong> ;</li>
<li>可以采用覆盖技术扩充内存:</li>
<li>不一定需要采取内存保护（eg:早期的PC操作系统MS-DOS)。</li>
</ol>
<p><strong><em>缺点</em></strong> :</p>
<ol>
<li>只能用于单用户、单任务的操作系统中;</li>
<li>有内部碎片;</li>
<li>存储器利用率极低。</li>
</ol>
<p>ps：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”</p>
<h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为 <strong><em>若千个固定大小的分区，在每个分区中只装入一道作业</em></strong> ，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p>
<ul>
<li><p>分区大小相等</p>
<ol>
<li>缺乏灵活性;</li>
<li>但是很适合用于用一台计算机控制多个 <strong><em>相同对象</em></strong> 的场合（比如:钢铁广有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)</li>
</ol>
</li>
<li><p>分区大小不等</p>
<ol>
<li>增加了灵活性;</li>
<li>可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区、适量中等分区、少量大分区)</li>
</ol>
</li>
<li><p>操作系统需要建立一个数据结构 &gt;&gt;&gt; <strong><em>分区说明表</em></strong> ，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、 <strong><em>起始地址</em></strong> 、 <strong><em>状态</em></strong> （是否已分配）。</p>
</li>
<li><p>用数据结构的数组(或链表)即可表示这个表。</p>
</li>
<li><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p>
</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/table.png" class title="This is an example image"></div>

<p><strong><em>优点</em></strong> :实现简单，无 <strong><em>外部</em></strong> 碎片。<br><strong><em>缺点</em></strong> : </p>
<ol>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能;</li>
<li>会产生 <strong><em>内部</em></strong> 碎片，内存利用率低。</li>
</ol>
<h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p><strong><em>动态分区分配</em></strong> 又称为 <strong><em>可变分区分配</em></strong> 。这种分配方式 <strong><em>不会预先划分内存分区</em></strong> ，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB.….)</p>
<p><strong><em>问题:</em></strong> </p>
<ol>
<li>系统要用什么样的数据结构记录内存的使用情况?</li>
<li>当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?</li>
<li>如何进行分区的分配与回收操作?</li>
</ol>
<h3 id="系统要用什么样的数据结构记录内存的使用情况"><a href="#系统要用什么样的数据结构记录内存的使用情况" class="headerlink" title="系统要用什么样的数据结构记录内存的使用情况?"></a>系统要用什么样的数据结构记录内存的使用情况?</h3><ul>
<li>两种常用的数据结构<ul>
<li>空闲分区表：空闲分区表:每个空闲分区对应个表项。表项中包含分区号、分区大小、分区起始地址等信息</li>
<li>空想分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>
</ul>
</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/speration.png" class title="This is an example image"></div>

<h3 id="当很多个空闲分区都能满足需求时-应该选择哪个分区进行分配"><a href="#当很多个空闲分区都能满足需求时-应该选择哪个分区进行分配" class="headerlink" title="当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?"></a>当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?</h3><p>&emsp;&emsp;应该用最大的分区进行分配?还是用最小的分区进行分配?又或是用地址最低的部分进行分配?<br>&emsp;&emsp;把一个新作业装入内存时，须按照一定的 <strong><em>动态分区分配算法</em></strong> ，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很天的影响，因此人们对它进行了广泛的研究。</p>
<h3 id="如何进行分区的分配与回收操作"><a href="#如何进行分区的分配与回收操作" class="headerlink" title="如何进行分区的分配与回收操作?"></a>如何进行分区的分配与回收操作?</h3><p>如果足够分配：</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg1.png" class title="This is an example image"></div>

<p>如果刚好分配完：</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg2.png" class title="This is an example image"></div>

<p>接下来讨论回收，<br>情况一:回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg3.png" class title="This is an example image"></div>

<p>情况二:回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg4.png" class title="This is an example image"></div>

<p>情况三:回收区的前、后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg5.png" class title="This is an example image"></div>

<p>情况四:回收区的前、后都没有相邻的空闲分区，新增一个表项<br>注:各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg6.png" class title="This is an example image"></div>

<h2 id="动态分区分配-1"><a href="#动态分区分配-1" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配没有 <strong><em>内部碎片</em></strong> ，但是有 <strong><em>外部碎片</em></strong> 。</p>
<ul>
<li>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上</li>
<li>外部碎片，是指内存中的某些空闲分区 <strong><em>由于太小而难以利用</em></strong> 。</li>
</ul>
<p>&emsp;&emsp;如果内存中空闲空间的总和本来可以满足某进程的要求,但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。<br>&emsp;&emsp;可以通过紧凑(拼凑，Compaction）技术来解决外部碎片。 &gt;&gt;&gt; 将已分配的内存进行挪位，腾出一个大空间<br>&emsp;&emsp;动态重定位装入方式最适合这里的紧凑技术，紧凑之后需要将各个进程的起始地址修改，一般存放在进程对应的PCB中，进程上CPU之前会把进程起始地址放到重定位寄存器中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/conclusion.png" class title="This is an example image"></div>

<p>总之,相邻的空闲分区要合并<br>另外，需要对用于管理空闲分区的数据结构有印象 –&gt; 空闲分区表、空闲分区链</p>
<h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><p>动态分区分配算法:在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p>
<ul>
<li>首次适应算法(First Fit)</li>
<li>最佳适应算法(Best Fit)</li>
<li>最坏适应算法(Worst Fit)</li>
<li>邻近适应算法(Next Fit)</li>
</ul>
<h2 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h2><p><strong><em>算法思想</em></strong> :每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<br><strong><em>如何实现</em></strong> :空闲分区以 <strong><em>地址递增</em></strong> 的次序排列。每次分配内存时 <strong><em>顺序查找</em></strong> 空闲分区链（或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<h2 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h2><p><strong><em>算法思想</em></strong> :由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以 <strong><em>尽可能多地留下大片的空闲区</em></strong> ，即， <strong><em>优先使用更小</em></strong> 的空闲区。<br><strong><em>如何实现</em></strong> :空闲分区 <strong><em>按容量递增次序链接</em></strong> 。每次分配内存时顺序查找 <strong><em>空闲分区链</em></strong> （或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p><strong><em>缺点:</em></strong><br>每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的 <strong><em>外部碎片</em></strong> 。</p>
<h2 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h2><p>又称最大适应算法（Largest Fit)<br><strong><em>算法思想</em></strong> :为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。<br><strong><em>如何实现</em></strong> :空闲分区 <strong><em>按容量递减次序</em></strong> 链接。每次分配内存时顺序查找 <strong><em>空闲分区链</em></strong> （或空闲分区表），找到大小能满足要求的第一个空闲分区。重写表后，重新排序。</p>
<p><strong><em>缺点:</em></strong><br>每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p>
<h2 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h2><p><strong><em>算法思想</em></strong> :首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。<br><strong><em>如何实现</em></strong> :空闲分区 <strong><em>以地址递增</em></strong> 的顺序排列（可排成一个循环链表)。每次分配内存时 <strong><em>从上次查找结束的位置</em></strong> 开始查找 <strong><em>空闲分区链</em></strong> （或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<ul>
<li>好处是，算法开销较小，不需要重新排列列表。</li>
<li>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的天分区保留下来（最佳适应算法的优点)</li>
<li>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点)<br>综合来看,四种算法中, <strong><em>首次适应算法</em></strong> 的效果反而更好</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/conclusion1.png" class title="This is an example image"></div>

<p>开销 &gt;&gt;&gt; 每次都需要重新排序</p>
<h1 id="连续分配方式的缺点"><a href="#连续分配方式的缺点" class="headerlink" title="连续分配方式的缺点"></a>连续分配方式的缺点</h1><p>考虑支持多道程序的两种连续分配方式:</p>
<ol>
<li>固定分区分配:缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。</li>
<li>动态分区分配:会产生很多外部碎片，虽然可以用“紧淡”技术来处理，但是“紧凑”的时间代价很高</li>
</ol>
<p>原因是，连续分配方式必须要求占用一块连续的区域。<br>如果允许将一个述程分散地装入到许多不相邻的分区中,便可充分地利用内存，而无需再进行“紧凌”<br>基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。</p>
<p><strong><em>连续分配</em></strong> :为用户进程分配的必须是一个 <strong><em>连续的内存空间</em></strong> 。<br><strong><em>非连续分配</em></strong> :为用户进程分配的可以是一些 <strong><em>分散的内存空间</em></strong> 。</p>
<h1 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h1><h2 id="把固定分区分配改造为非连续分配版本"><a href="#把固定分区分配改造为非连续分配版本" class="headerlink" title="把固定分区分配改造为非连续分配版本"></a>把固定分区分配改造为非连续分配版本</h2><ul>
<li>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</li>
<li>解决思路:如果允许进程占用多个分区，那么可以把进程拆分成 10MB + 10MB + 3MB三个部分，再把这三个部分分别放到三个分区中(这些分区不要求连续）…</li>
<li>进程A的最后一个部分是3MB，放入分区后会产生7MB的内部碎片。</li>
<li>如果每个分区大小为 2MB，那么进程A可以拆分成11 * 2能B+1MB共 12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。</li>
<li>显然，如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。</li>
</ul>
<p>基本分页存储管理的思想 — 把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分</p>
<h2 id="分配存储管理的基本概念"><a href="#分配存储管理的基本概念" class="headerlink" title="分配存储管理的基本概念"></a>分配存储管理的基本概念</h2><ul>
<li>将内存空间分为一个个大小相等的分区（比如:每个分区4KB)，每个分区就是一个 <strong><em>“页框”</em></strong> ，或称 <strong><em>“页帧”</em></strong> 、 <strong><em>“内存块”</em></strong> 、 <strong><em>“物理块”</em></strong> 。每个页框有一个编号，即 <strong><em>“页框号”</em></strong> (或者 <strong><em>“内存块号”、“页帧号”、“物理块号”</em></strong> ）页框号 <strong><em>从0开始</em></strong> 。</li>
<li>将用户进程的地址空间也分为 <strong><em>与页框大小相等</em></strong> 的一个个区域，称为 <strong><em>“页”或“页面”</em></strong> 。每个页面也有一个编号，即“页号”，页号也是从0开始。( <strong><em>注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片</em></strong> )</li>
<li>操作系统以 <strong><em>页框</em></strong> 为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的 <strong><em>页面与内存</em></strong> 的页框有 <strong><em>一一对应</em></strong> 的关系。</li>
<li>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</li>
</ul>
<h2 id="如何实现地址转换"><a href="#如何实现地址转换" class="headerlink" title="如何实现地址转换"></a>如何实现地址转换</h2><p>将进程地址空间分页之后,操作系统该如何实现逻辑地址到物理地址的转换?</p>
<h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><p>重定位寄存器:存放装入模块存放的起始位置<br>思想:模块在内存中的的 <strong><em>“起始地址”</em></strong> ＋目标内存单元相对于起始位置的 <strong><em>“偏移量”</em></strong> </p>
<p>如果采用分页技术,应该如何实现地址转换?<br>CPU执行指令1，需要访问逻辑地址为80的内存单元，如何转化为物理地址?</p>
<ul>
<li>逻辑地址为80的内存单元:</li>
<li>应该在 <strong><em>1号页</em></strong> ，该页在内存中的 <strong><em>起始位置为450</em></strong> ，逻辑地址为80的内存单元相对于该页的起始地址而言， <strong><em>“偏移量”应该是30</em></strong> 。</li>
<li>实际物理地址=450 + 30 = 480</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/change.png" class title="This is an example image"></div>

<ol>
<li>要算出逻辑地址对应的 <strong><em>页号</em></strong> </li>
<li>要知道该页号对应页面在内存中的 <strong><em>起始地址</em></strong> </li>
<li>要算出逻辑地址 <strong><em>在页面内的“偏移量”</em></strong> </li>
<li>物理地址 = 页面始址 ＋页内偏移量</li>
</ol>
<p>如何计算:</p>
<ul>
<li>页号 = 逻辑地址 / 页面长度(取除法的整数部分)</li>
<li>页内偏移量 = 逻辑地址 % (页面长度取除法的余数部分) <strong><em>页面在内存中的起始位置</em></strong> :操作系统需要用某种数据结构记录进程各个页面的起始位置。</li>
</ul>
<p>eg:</p>
<ul>
<li>页号= 80 / 50 = 1</li>
<li>页内偏移量 = 80 % 50 = 30</li>
<li><strong><em>1号页</em></strong> 在内存中存放的 <strong><em>起始位置</em></strong> 450</li>
</ul>
<p>在计算机中，为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂</p>
<p>如何计算:</p>
<ul>
<li>页号 = 逻辑地址 / 页面长度(取除法的整数部分)</li>
<li>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分)</li>
<li>假设用32个二进制位表示逻辑地址，页面大小为2<sup>12</sup>B = 4096B = 4KB</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/eg7.png" class title="This is an example image"></div>

<p>Eg:逻辑地址2，用二进制表示应该是00000000000000000000 <strong><em>000000000010</em></strong><br>若0号页在内存中的起始地址为x，则逻辑地址2对应的物理地址应该是X+000000000010<br>Eg:逻辑地址4097，用二进制表示应该是00000000000000000001 <strong><em>000000000001</em></strong><br>若1号页在内存中的起始地址为x，则逻辑地址4097对应的物理地址应该是X+000000000001</p>
<p>与另一种算法的结果对比:<br>页号 = 逻辑地址 / 页面长度<br>页内偏移量 = 逻辑地址 % 页面长度</p>
<p>结论:如果每个页面大小为2<sup>k</sup>B，用二进制数表示逻辑地址，则末尾K位即为 <strong><em>页内偏移量</em></strong> ，其余部分就是 <strong><em>页号</em></strong><br>因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p>
<h2 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h2><p>分页存储管理的逻辑地址结构如下所示:</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/strature.png" class title="This is an example image"></div>

<p>地址结构包含两个部分:前一部分为页号，后一部分为页内偏移量W。在上图所示的例子中，地址长度为32位，其中0 ~ 11位为 <strong><em>“页内偏移量”</em></strong> ，或称 <strong><em>“页内地址”</em></strong> ;12 ~ 31位为 <strong><em>“页号”</em></strong> 。</p>
<ul>
<li>如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2<sup>k</sup>个内存单元</li>
<li>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2<sup>M</sup>个页面</li>
</ul>
<p>分页存储管理中，如何实现地址转换?</p>
<ol>
<li>要算出逻辑地址对应的页号</li>
<li>要知道该页号对应页面在内存中的起始地址</li>
<li>要算出逻辑地址在页面内的“偏移量”</li>
<li>物理地址 = 页面始址 + 页内偏移量</li>
</ol>
<p>注:如果题目中是用十进制数表示逻辑地址，则</p>
<ul>
<li>页号 = 逻辑地址 / 页面长度(取除法的整数部分)</li>
<li>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分)</li>
</ul>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p>
<ol>
<li>一个进程对应一张页表</li>
<li>进程的每一页对应一个页表项</li>
<li>每个页表项由“页号”和“块号”组成</li>
<li>页表记录进程页面和实际存放的内存块之间的对应关系</li>
</ol>
<div style="width:70%;margin:auto"></div>

<p>M号内存块的起始地址 = M * 内存块大小</p>
<p>为什么每个页表项的长度是相同的，页号是“隐含”的? &gt;&gt;&gt; 页表项中不用记录页号<br>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节?<br>4GB = 2<sup>32</sup>B，4KB = 2<sup>12</sup>B<br>因此4GB 的内存总共会被分为 2<sup>32</sup> / 2<sup>12</sup> = 2<sup>20</sup>个内存块，因此内存块号的范围应该是0 ~ 2<sup>20</sup> - 1因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够（每个字节8个二进制位，3个字节共24个二进制位&gt;</p>
<ul>
<li>各页表项会按顺序连续地存放在内存中</li>
<li>如果该页表在内存中存放的起始地址为×，则M号页对应的页表项一定是存放在内存地址为×＋3 * M因此,页表中的“页号”可以是“隐含”的。</li>
<li>只需要知道页表存放的起始地址和页表项长度，即可找到各个页号对应的页表项存放的位置</li>
</ul>
<p>在本例中，一个页表项占3B，如果进程由n个页面，则该进程的页表总共会占3 * n个字节</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/conclusion2.png" class title="This is an example image"></div>

<h1 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h1><p>重点理解、记忆基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）的原理和流程</p>
<h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><ul>
<li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</li>
<li>通常会在系统中设置一个 <strong><em>页表寄存器</em></strong> （PTR），存放 <strong><em>页表在内存中的起始地址F和页表长度M</em></strong> 。进程未执行时，页表的始址和页表长度放在 <strong><em>进程控制块</em></strong> （PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</li>
<li>注意:页面大小是2的整数幂</li>
<li>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</li>
</ul>
<p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<ol>
<li>计算页号 Р 和页内偏移量 w （如果用十进制数手算，则 P = A / L，W = A % L:但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li>
<li>比较页号 P 和页表长度 M ，若 P ≥ M ，则产生越界中断，否则继续执行。(注意:页号是从0开始的，而页表长度至少是1，因此P=M时也会越界）</li>
<li>页表中页号P对应的页表项地址 = 页表起始地址 F + 页号 P * 页表项长度，取出该页表项内容 b ,即为内存块号。（注意区 <strong><em>分页表项长度、页表长度、页面大小</em></strong> 的区别。 <strong><em>页表长度</em></strong> 指的是这个页表中总共有几个页表项，即总共有几个页; <strong><em>页表项长度</em></strong> 指的是每个页表项占多大的存储空间; <strong><em>页面大小</em></strong> 指的是一个页面占多大的存储空间)</li>
<li>计算E = b * L + W，用得到的物理地址 E 去访存。(如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)</li>
</ol>
<p>操作系统将内存分为系统区和用户区</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/PROCESS.png" class title="This is an example image"></div>

<p><strong><em>动手验证:</em></strong><br>假设页面大小 L= 1KB，最终要访问的内存块号b = 2，页内偏移量W= 1023。</p>
<ol>
<li>尝试用E= b * L + W 计算目标物理地址。</li>
<li>尝试把内存块号、页内偏移量用二进制表示，并把它们拼接起来得到物理地址。对比1、2的结果是否一致</li>
</ol>
<p>例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p>
<ul>
<li>等价描述:某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</li>
<li>说明一个页面的大小为2<sup>10</sup>sup&gt;B = 1KB</li>
</ul>
<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
<h2 id="对页表项大小的进一步探讨"><a href="#对页表项大小的进一步探讨" class="headerlink" title="对页表项大小的进一步探讨"></a>对页表项大小的进一步探讨</h2><p>每个页表项的长度是相同的，页号是“隐含”的<br>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，的内存总共会被分为2<sup>32</sup>/2<sup>12</sup>=2<sup>20</sup>个内存块，因此内存块号的范围应该是0 ~ 2<sup>20</sup>-1<br>因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够（每个字节8个二进制位，3个字节共24个二进制位)</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/table3.png" class title="This is an example image"></div>

<ul>
<li>各页表项会按顺序连续地存放在内存中</li>
<li>如果该页表在内存中存放的起始地址为 × ，则 M 号页对应的页表项是存放在内存地址为 × ＋ 3 * M</li>
<li>一个页面为4KB，则每个页框可以存放4096/3 = 1365个页表项，但是这个页框会剩余4096 % 3 = 1B页内碎片因此，1365号页表项存放的地址为X＋3 * 1365 + 1</li>
<li>如果每个页表项占4字节，则每个页框刚好可存放1024个页表项</li>
<li>1024号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用 X + 4 * 1024得出</li>
</ul>
<p>结论:理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项。<br>进程页表通常是装在连续的内存块中的</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/conclusion3.png" class title="This is an example image"></div>

<p>第一次访问内存:查页表<br>第二次访问内存:访问目标内存单元</p>
<h1 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h1><p>是基本地址变换机构的改进版本</p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line">int a[100];</span><br><span class="line">while (i &lt; 100)&#123;</span><br><span class="line">	a[i] &#x3D; i;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/part.png" class title="This is an example image"></div>

<p>这个程序执行时,会很频繁地访问10号、23号内存块。<br><strong><em>时间局部性</em></strong> :如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环)<br><strong><em>空间局部性</em></strong> :一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的)</p>
<p>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理， <strong><em>可能连续很多次查到的都是同一个页表项</em></strong> 。既然如此，能否利用这个特性减少访问页表的次数呢?</p>
<h2 id="什么是快表-TLB"><a href="#什么是快表-TLB" class="headerlink" title="什么是快表(TLB)"></a>什么是快表(TLB)</h2><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/proccess.png" class title="This is an example image"></div>

<ul>
<li>若快表命中，就不需要再访问内存了</li>
<li>若快表没有目标页表项，则需要查询内存中的页表</li>
<li>快表存放的是页表的一部分副本</li>
</ul>
<h2 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h2><ol>
<li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的 <strong><em>内存单元</em></strong> 。因此，若 <strong><em>快表命中</em></strong> ，则访问某个逻辑地址仅需 <strong><em>一次访存</em></strong> 即可。</li>
<li>如果没有找到匹配的页号，则需要 <strong><em>访问内存中的页表</em></strong> ，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后， <strong><em>访问</em></strong> 该物理地址对应的 <strong><em>内存单元</em></strong> 。因此,若快表未命中，则访问某个逻辑地址需要 <strong><em>两次访存</em></strong> （注意: <strong><em>在找到页表项后</em></strong> ，应 <strong><em>同时将其存入快表</em></strong> ，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。<br>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<br>(1 + 100) * 0.9 +(1 + 100 + 100) * 0.1 = 111 us<br>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1 + 100) * 0.9 + (100 + 100) * 0.1 = 110.9 us<br>若未采用快表机制，则访问一个逻辑地址需要 100 + 100  = 200us</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/02/01/supervisor-mode/conclusion4.png" class title="This is an example image"></div>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/01/supervisor-mode/" data-id="ckkzd1sxh0030w0wz7w5wa0eb" data-title="supervisor mode" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/" rel="tag">system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Overlay-and-swap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/30/Overlay-and-swap/" class="article-date">
  <time class="dt-published" datetime="2021-01-30T08:34:24.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/30/Overlay-and-swap/">Overlay and swap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><ul>
<li>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存因此经常会出现内存大小不够的情况。</li>
<li>后来人们引入了 <strong><em>覆盖技术</em></strong> ，用来解决“ <strong><em>程序大小超过物理内存总和</em></strong> ”的问题</li>
</ul>
<p><strong><em>覆盖技术的思想:</em></strong></p>
<ul>
<li>将程序分为多个段（多个模块)常用的段常驻内存，不常用的段在需要时调入内存。</li>
<li>内存中分为一个“固定区”和若干个“覆盖区”。</li>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束)</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/01/30/Overlay-and-swap/cover.png" class title="This is an example image"></div>

<p><strong><em>缺点</em></strong> :<br>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><ul>
<li>交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度)</li>
<li>将PCB保留在内存中，并且插入挂起队列。 &gt;&gt;&gt; 记录进程存放外存的位置</li>
<li>暂时换出外存等待的进程状态为挂起状态(挂起态，suspend)挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</li>
</ul>
<p>ps:中级调度就是为了实现交换技术而是用的调度策略。中级调度（内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<div style="width:70%;margin:auto"><img src="/2021/01/30/Overlay-and-swap/model.png" class title="This is an example image"></div>

<h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><ol>
<li>应该在外存（磁盘）的什么位置保存被换出的进程?</li>
<li>什么时候应该交换?</li>
<li>应该换出哪些进程?</li>
</ol>
<p><strong><em>答：</em></strong></p>
<ol>
<li>具有对换功能的操作系统中，通常把磁盘空间分为 <strong><em>文件区</em></strong> 和 <strong><em>对换区</em></strong> 两部分。文件区主要用于存放文件，主要 <strong><em>追求存储空间的利用率</em></strong> ，因此对文件区空间的管理采用 <strong><em>离散分配方式</em></strong> ; <strong><em>对换区</em></strong> 空间只占磁盘空间的小部分， <strong><em>被换出的进程数据就存放在对换区</em></strong> 。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要 <strong><em>追求换入换出速度</em></strong> ，因此通常对换区 <strong><em>采用连续分配方式</em></strong> （学过文件管理章节后即可理解）。总之， <strong><em>对换区的I/o速度比文件区的更快</em></strong> 。 &gt;&gt;&gt; 数据换出存放在对换区，换入也是从对换区换回</li>
<li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</li>
<li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间..</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div style="width:70%;margin:auto"><img src="/2021/01/30/Overlay-and-swap/conclusion.png" class title="This is an example image"></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/30/Overlay-and-swap/" data-id="ckkzd1swd000tw0wz8awgeka8" data-title="Overlay and swap" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/" rel="tag">system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java-day13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Java-day13/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T13:07:33.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Java-day13/">Java day13</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>电脑整体环境</p>
<ul>
<li>桌面上尽量不要放文件</li>
<li>除了系统组件以外，其他的软件尽量安装在D盘</li>
<li>每当新安装软件时，都要先准备一个新的文件夹</li>
<li>软件安装的路径中，应该尽量避免中文与空格</li>
<li>C盘装系统；D盘装应用软件；E盘装软件产生的数据；F盘存放长久保留的文件</li>
<li>Windows10 Windows7 尽量避免 Window8/XP 尽量选择64位系统</li>
</ul>
</li>
<li><p>JAVASE</p>
<ul>
<li>Java300集</li>
<li>JDK java开发工具包 推荐JDK8</li>
<li>Notepad++ 一款灵巧的纯文本编辑工具</li>
<li>idea 2019-2 java 集成开发环境 html &gt;&gt;&gt; hbuilder java &gt;&gt;&gt; idea</li>
</ul>
</li>
</ol>
<p>JDK安装时可以放在C盘，不会产生什么垃圾，而且运行更快一些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_281\</span><br></pre></td></tr></table></figure>
<p>测试JDK是否安装成功:win + r &gt;&gt;&gt; cmd &gt;&gt;&gt; java -version<br>Notepad++ 一路next即可</p>
<h1 id="计算机知识"><a href="#计算机知识" class="headerlink" title="计算机知识"></a>计算机知识</h1><h2 id="计算机开机过程"><a href="#计算机开机过程" class="headerlink" title="计算机开机过程"></a>计算机开机过程</h2><ul>
<li>核心计算元件 CPU</li>
<li>运行内存 RAM &gt;&gt;&gt; 存储量小，断电后数据消失，数据读写速度飞快</li>
<li>硬盘 DISK &gt;&gt;&gt; 磁盘一直处于转动状态，用探针在上面读取数据 &gt;&gt;&gt; 磁盘存储大量数据，断电后数据不会消失，容量大，但是数据读取速度慢</li>
<li>显卡 GPU 图形架构器</li>
</ul>
<p>为了解决磁盘与CPU交互慢的问题，先预加载一部分数据进入RAM。<br>系统启动之前，就是磁盘中的数据，启动将一部分系统数据加载进入RAM，大约几个G的数据，这个过程耗费时间长。</p>
<h2 id="程序启动过程"><a href="#程序启动过程" class="headerlink" title="程序启动过程"></a>程序启动过程</h2><p>没有启动之前，就是磁盘中的文件，启动就是磁盘中的文件进入RAM的过程</p>
<ul>
<li>电脑开启了一个进程:一个软件的启动 软件本身的文件从硬盘进入到内存</li>
<li>进程代表了一个软件的启动，但是软件的启动不代表了有任务要进行。</li>
<li>一个进程中可以同时开启多个任务，每个任务专业称呼线程</li>
</ul>
<p><strong><em>内存大小</em></strong> :内存越大，代表设备可以运行的程序就越多。</p>
<ul>
<li>内存满了，就会在磁盘上开辟一个小的虚拟内存，此处就当做内存使用，这是就会导致速度变慢，发生卡顿。 &gt;&gt;&gt; 内存大一些，就可以同时开启的任务多一些</li>
<li>CPU的线程数:CPU可以同时执行的任务数量 &gt;&gt;&gt; 多核多线程CPU</li>
<li>CPU的单线程运算能力，每个独立的线程的运算能力</li>
<li>传统机械硬盘，温彻斯特硬盘 &gt;&gt;&gt; 内部有硬盘和磁头机械结构</li>
<li>固态硬盘，读写速度非常快 &gt;&gt;&gt; 是一般机械硬盘读写速度的10倍，一些类似于内存的存储模块</li>
<li>但是要想程序跑得快，还是要CPU的运算能力强一些才行</li>
<li>如果电脑装了固态硬盘，内存尽量大些</li>
<li>因为如果电脑要开辟虚拟内存，内存的读写时非常频繁的，至少上万次，会进行反复的擦写。而固态硬盘的读写能力远远低于传统硬盘，如果进行高频率的读写，会影响固态硬盘的寿命</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2021/01/29/Java-day13/intro.png" class title="This is an example image"></div>

<p>查看设备:我的电脑属性 &gt;&gt;&gt; 设备管理器</p>
<p>ps:因特尔CPU i3 i5 i7 的最重要差别区别是 线程数，核心数</p>
<h1 id="计算机语言发展史"><a href="#计算机语言发展史" class="headerlink" title="计算机语言发展史"></a>计算机语言发展史</h1><ul>
<li><p>人类语言 人类间沟通</p>
</li>
<li><p>计算机语言 跟计算机说话</p>
</li>
<li><p>计算机会思考 但是要教他 不会有自我意识</p>
<h2 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h2></li>
<li><p>第一代 机器语言 二进制代码</p>
</li>
<li><p>第二代 汇编语言 简单的英语单词 VB有点类似但是不一样</p>
</li>
<li><p>第三代 高级语言 </p>
<ul>
<li>面向对象 &gt;&gt;&gt; C/Fortran/COBOL/PASCAL/ADA</li>
<li>面向过程 &gt;&gt;&gt; C++/C#/java</li>
</ul>
</li>
</ul>
<p>ps:从高级语言转为低级语言的过程称为 <strong><em>编译</em></strong></p>
<h1 id="Java历史"><a href="#Java历史" class="headerlink" title="Java历史"></a>Java历史</h1><ul>
<li>SUN公司</li>
<li>Java为什么被发明</li>
<li>Java的发明人</li>
<li>经历阶段</li>
<li>Java核心机制<ul>
<li>垃圾回收机制</li>
<li>跨平台机制</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>方案一:手动移除数据<br>方案二:自动移除数据</p>
<h2 id="跨平台机制"><a href="#跨平台机制" class="headerlink" title="跨平台机制"></a>跨平台机制</h2><p>Java的跨平台机制优越 同样的代码可以在不同的终端使用<br>互联网的发展 需要程序在多种不同的平台上 终端上运行 要求我们的程序在跨平台处理上有这非常方便的形式和优越的性能</p>
<p>JAVA源代码 &gt;&gt;&gt; JAVA字节码 &gt;&gt;&gt; JVM(翻译)JAVA Virtual machine &gt;&gt;&gt; 各种系统<br>服务器系统 &gt;&gt;&gt; Windows/Linux/Unix<br>不同操作系统的内核算法是不一样的 使用的指令集是有差异的 甚至硬件上都有一些差异 编译之后的JAVA字节码不能够直接在各个系统上运行 需要在各个系统上安装虚拟机 通过虚拟机向平台解释JAVA字节码的含义<br>JAVA源代码 需要编译1次 有虚拟机向每个平台去解释 要想实现跨平台 必须要有虚拟机 虚拟机由oracle公司开发的<br>目前市场上主要的操作系统 都有对应的虚拟机<br>JAVA的核心优势 跨平台性能<br>JAVA的核心技术 虚拟机技术<br>JAVA技术的瓶颈 虚拟机技术</p>
<ul>
<li>C语言编译 直接生成各个系统可识别 可直接运行的代码文件</li>
<li>C语言更快</li>
</ul>
<p>JAVA的字节是一种中立的二进制代码文件<br>宏观上的程序 &gt;&gt;&gt; 靠近用户要求的功能<br>系统工具 如驱动程序 &gt;&gt;&gt; 用C语言实现更快<br>虚拟机已经在JDK中安装了</p>
<h1 id="常用计算机指令"><a href="#常用计算机指令" class="headerlink" title="常用计算机指令"></a>常用计算机指令</h1><h2 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h2><h3 id="DOS操作系统"><a href="#DOS操作系统" class="headerlink" title="DOS操作系统"></a>DOS操作系统</h3><ul>
<li>Disk Operating system 磁盘操作系统</li>
<li>DOS是单用户 单任务的操作系统</li>
</ul>
<h3 id="DOS命令-1"><a href="#DOS命令-1" class="headerlink" title="DOS命令"></a>DOS命令</h3><ul>
<li>在windows中 通过鼠标键盘来操作系统 要通过dos命令来实现操作系统</li>
<li>DOS命令 是一种面向磁盘的操作命令</li>
</ul>
<h3 id="命令学习"><a href="#命令学习" class="headerlink" title="命令学习"></a>命令学习</h3><p>win + r &gt;&gt;&gt; cmd</p>
<p><strong><em>掌握的命令</em></strong></p>
<ul>
<li><p>DIR(directory) :显示目录详细信息</p>
<ul>
<li>dir代表了该文件是一个文件夹(目录)</li>
<li>一些文件都用英文翻译了</li>
<li>创建时间 + 修改时间 + 文件类型 + 文件大小 + 文件名</li>
<li>.代表本层目录 ..代表上层目录</li>
<li>dir /s 查看各个层级的子文件和子目录</li>
<li>显示当前层次所有文件和目录 包含隐藏的  dir /a</li>
</ul>
</li>
<li><p>CD(change directory) :改变程序显示当前目录</p>
<ul>
<li>切换硬盘 d:</li>
<li>进入文件夹 cd &lt;文件夹名&gt;</li>
<li>进入上一层目录 cd ..</li>
<li>进入根目录 cd /</li>
</ul>
</li>
<li><p>CLS(clear screen) :清除屏幕 但历史记录还在 按向上键查看</p>
</li>
<li><p>切换盘符:快速切换盘符 d:</p>
</li>
<li><p>Tab:自动补充键</p>
</li>
<li><p>MD(make directory) :建立目录</p>
</li>
<li><p>RD(remove directory) :删除目录</p>
</li>
<li><p>copy :复制文件</p>
</li>
<li><p>DEL(delete) ：删除文件</p>
<ul>
<li>del a 删除文件夹下内容</li>
<li>del a.txt 删除文件</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Java-day13/" data-id="ckkzd1swk001aw0wzd02641s7" data-title="Java day13" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming-Language/" rel="tag">Programming Language</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-network of computer2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/network%20of%20computer2/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T13:01:27.749Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/network%20of%20computer2/">network of computer2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="互联网的核心部分-路由器（router）"><a href="#互联网的核心部分-路由器（router）" class="headerlink" title="互联网的核心部分-路由器（router）"></a>互联网的核心部分-路由器（router）</h1><p>&emsp;&emsp;路由器是实现分组交换（packet switching）的关键构建，任务是转发收到的分组</p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>&emsp;&emsp;N路电话机两两直接 相连，需要N（N-1）对电线。这种直接连接的方法所需的电线对的数量与电话机数量的平方（N^2）成正比</p>
<h2 id="使用交换机"><a href="#使用交换机" class="headerlink" title="使用交换机"></a>使用交换机</h2><p>&emsp;&emsp;当电话机数量增多时，就要用交换机来完成全网的交换任务。用交换机代替电路交换中的线路，使得所需的电线对大大减少。每一部交换机都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便的通信。所采用的交换方式就是电路交换（circuit switching）</p>
<h2 id="交换的含义"><a href="#交换的含义" class="headerlink" title="交换的含义"></a>交换的含义</h2><p>&emsp;&emsp;交换就是按照某种方式动态地分配传输线路的资源。</p>
<h2 id="电路交换特点"><a href="#电路交换特点" class="headerlink" title="电路交换特点"></a>电路交换特点</h2><p>&emsp;&emsp;电路交换必定是面向连接的，首先要建立连接才能进行通信。</p>
<ul>
<li>建立连接</li>
<li>通信</li>
<li>释放连接</li>
</ul>
<h2 id="电路交换优点"><a href="#电路交换优点" class="headerlink" title="电路交换优点"></a>电路交换优点</h2><p>&emsp;&emsp;电路交换的用户始终占用端到端的连接。</p>
<h2 id="电路交换缺点"><a href="#电路交换缺点" class="headerlink" title="电路交换缺点"></a>电路交换缺点</h2><ul>
<li>计算机数据具有突发性，导致传送计算机数据时，通信线路的利用率很低（用来传送数据的时间往往不到10%甚至更低）</li>
</ul>
<h2 id="分组交换的主要特点"><a href="#分组交换的主要特点" class="headerlink" title="分组交换的主要特点"></a>分组交换的主要特点</h2><p>&emsp;&emsp;分组交换占用时间大大缩短,一小段报文经过之后，信道便空闲出来，其他端便可以占用此信道。提高传输的效率。</p>
<ul>
<li><strong><em>分组交换</em></strong> 用 <strong><em>存储转发技术</em></strong> 。</li>
<li>在发送端，把较长的报文划分成较短的、固定长度的数据段。（固定长度，提高传输效率）</li>
<li>每个数据段前面添加上首部构成分组（packet）</li>
</ul>
<h3 id="分组首部"><a href="#分组首部" class="headerlink" title="分组首部"></a>分组首部</h3><ul>
<li>每一个分组首部都含有地址等控制信息。</li>
<li>分组交换网中的节点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点 交换机</li>
<li>每一个分组在互联网中**<em>独立地选择传输路径**</em></li>
</ul>
<h2 id="路由器处理分组过程"><a href="#路由器处理分组过程" class="headerlink" title="路由器处理分组过程"></a>路由器处理分组过程</h2><ul>
<li>把收到的分组先放入缓存</li>
<li><strong><em>查找转发表</em></strong>，找到某个目的地址应该从哪个端口转发</li>
<li>把分组送到适当的端口转发出去</li>
</ul>
<p>ps:<strong><em>路由器是一个功能特殊的主机</em></strong></p>
<h2 id="分组交换的优点"><a href="#分组交换的优点" class="headerlink" title="分组交换的优点"></a>分组交换的优点</h2><table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">手段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高效</td>
<td align="center">动态分配传输带宽</td>
</tr>
<tr>
<td align="center">灵活</td>
<td align="center">独立选择合适转发路由</td>
</tr>
<tr>
<td align="center">迅速</td>
<td align="center">可以不先建立连接</td>
</tr>
<tr>
<td align="center">可靠</td>
<td align="center">网络协议，很好生存性</td>
</tr>
</tbody></table>
<h2 id="分组交换问题"><a href="#分组交换问题" class="headerlink" title="分组交换问题"></a>分组交换问题</h2><ul>
<li>存储转发有时延</li>
<li>首部必须有，造成开销</li>
</ul>
<p>ps:<strong><em>分组交换就是把报文交换分成许多小的组，分时间端转发，提高了信道利用率。</em></strong><br>ps:报文交换虽然转发完成后信道空闲出来了，但是传输时间更长。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/network%20of%20computer2/" data-id="ckkzd1sx2002iw0wza3zjdx4m" data-title="network of computer2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Internet/" rel="tag">Internet</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java day1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Java%20day1/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T13:01:27.714Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Java%20day1/">Java day1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="互联网技术概念入门"><a href="#互联网技术概念入门" class="headerlink" title="互联网技术概念入门"></a>互联网技术概念入门</h1><h2 id="CS-BS模式-互联网软件的两种模式"><a href="#CS-BS模式-互联网软件的两种模式" class="headerlink" title="CS/BS模式-互联网软件的两种模式"></a>CS/BS模式-互联网软件的两种模式</h2><p>ps:CS - Client/Server</p>
<ul>
<li><p>客户端/服务器模式–所下载的软件即是客户端</p>
<ol>
<li>需要下载安装客户端</li>
<li>软件有客户端和服务端两部分组成</li>
<li>软件更新比较麻烦 所有客户端都需要更新</li>
<li>运算压力可以分摊给各个终端 服务器压力大大减少</li>
</ol>
<p>ps:BS - Browser/Severe</p>
</li>
<li><p>浏览器/服务器模式(各种网站)</p>
<ol>
<li>不需要下载安装客户端，只需要有一个浏览器即可</li>
<li>软件全部部署在服务器端</li>
<li>软件更新比较简单 只要更新服务器即可</li>
<li>运算压力基本在服务端 一般不会用来做大型游戏</li>
</ol>
<p>Java语言更适用于BS模式</p>
</li>
</ul>
<h2 id="互联网三大基石-URL-HTTP协议-HTML"><a href="#互联网三大基石-URL-HTTP协议-HTML" class="headerlink" title="互联网三大基石-URL HTTP协议 HTML"></a>互联网三大基石-URL HTTP协议 HTML</h2><p>互联网软件以来的三种基础技术</p>
<ul>
<li>URL - 统一资源定位符</li>
<li>HTTP协议 - 数据解析的规范（双方都认识的规范发送与解读）</li>
<li>HTML - 数据传输的载体（数据的内容）</li>
</ul>
<p>假设小明小红 传纸条</p>
<ul>
<li>URL 小红的地址 小明的地址</li>
<li>HTTP协议 以中文发送 “中文”就是一个共同的解析数据的规范</li>
<li>HTML纸条上的内容 信息的载体 &gt;&gt;&gt;晚上看电影</li>
</ul>
<h1 id="HTML入门"><a href="#HTML入门" class="headerlink" title="HTML入门"></a>HTML入门</h1><h2 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h2><ul>
<li>HTML 是一种用来描述网页的一种语言</li>
<li>HTML 指的是超文本标记语言：HyperText Markup Language<ol>
<li>超文本：比普通文本更强 不仅仅可以展示文字 还可以展示各种媒体内容</li>
<li>一般由前端工作人员来完成，后台研发人员正常不需要</li>
<li>标记：（标签/元素/标记）<br>标记通常被称为 HTML 标签 （HTML tag）<ul>
<li>HTML 标签是由尖括号包围的关键词，比如 <code>&lt;html&gt;</code></li>
<li>封闭类标记（也称为双标记），必须成对出现，如<code>&lt;p&gt;&lt;/p&gt;</code></li>
<li>标签对中的第一个标签是开始标签，第二个是结束标签</li>
<li>开始和结束标签也称为开放标签和闭合标签</li>
<li>非封闭类标记，也叫作空标记，或者单标记，如<code>&lt;br/&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<p>ps:可以在自己的电脑上编写，也可以通过网络去访问服务器的文件</p>
<p>总结：我们学习HTML就是学习各种各样的标签，可以达到比普通标签更厉害的功能，那么后续浏览器可以对html文件做解析，就可以在浏览器上展示好看的效果。<br>ps:文件+文件扩展名</p>
<h2 id="HTML的作用"><a href="#HTML的作用" class="headerlink" title="HTML的作用"></a>HTML的作用</h2><p>&emsp;&emsp;通过使用HTML的各种标签，然后生成一个HTML文件，这个文件可以被浏览器解析，浏览器内都有一个专门的 HTML 的解析器，解析后我们就可以看到炫酷的页面。（编写网页的超文本标记语言）<br>ps:文件扩展名 windows上每个文件都有扩展名<br>ps:文件扩展名代表文件的类型 Windows 可以根据文件的扩展名去自动选择文件打开的程序。<br>ps:一般win7和win10默认隐藏文件扩展名<br>网页文件 扩展名为 .html 或者 html 的纯文本文件</p>
<h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>HTML 4.01 – 1999<br>HTML 5    – 2012<br>ps：许多仍用HTML4，但现用HTML5</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>新建一个文本文档，将文本文档后缀改为.html(HTML不区分大小写，建议小写)</li>
<li>右键 用记事本打开，编写代码</li>
</ol>
<p>ps:浏览器可以展示html文件中的文字，但是不能修改其中类容，用记事本打开即可<br>ps:<code>&lt;h1&gt;&lt;/h1&gt;</code> – 变大变粗</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Java%20day1/" data-id="ckkzd1svu0003w0wz8nbz92cr" data-title="Java day1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming-Language/" rel="tag">Programming Language</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T12:30:53.895Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/hello-world/" data-id="ckkzd1swn001jw0wzb6cl9yvs" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Internet/" rel="tag">Internet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming-Language/" rel="tag">Programming Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/issues/" rel="tag">issues</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start-here/" rel="tag">start here</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/system/" rel="tag">system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/writing/" rel="tag">writing</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Internet/" style="font-size: 15px;">Internet</a> <a href="/tags/Programming-Language/" style="font-size: 17.5px;">Programming Language</a> <a href="/tags/issues/" style="font-size: 10px;">issues</a> <a href="/tags/start-here/" style="font-size: 12.5px;">start here</a> <a href="/tags/system/" style="font-size: 20px;">system</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/09/Java-day15/">Java day15</a>
          </li>
        
          <li>
            <a href="/2021/02/06/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">虚拟内存</a>
          </li>
        
          <li>
            <a href="/2021/02/04/%E9%A1%B5%E8%A1%A8/">页表</a>
          </li>
        
          <li>
            <a href="/2021/02/02/Java-day14/">Java day14</a>
          </li>
        
          <li>
            <a href="/2021/02/01/supervisor-mode/">supervisor mode</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>